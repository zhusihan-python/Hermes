using Hermes.Communication.SerialPort;
using Hermes.Common;
using Moq;
using Hermes.Models;

namespace HermesTests.Communication.SerialPort;

public class ComPortTests : IClassFixture<ComPortFixture>
{
    private readonly ComPortFixture _fixture;
    public ComPortTests(ComPortFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact]
    public async Task MoveFromHeadToTail()
    {
        var clearAll = new FlowActionWrite().
                WithOperationType(0x00). // 清空
                WithMasterAddress<FlowActionWrite>(0xF2).
                WithSlaveAddress<FlowActionWrite>(0x13).
                WithActionSequence(new byte[] { 0x00, 0x00 }).
                WithActionType(0x02).
                WithPickCount(0x00).
                WithSrcDstLocations(new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }).
                GenData();
        await _fixture.comPort.SendPacket(clearAll);
        await Task.Delay(1000);

        var actionCount = 20;
        var actionsCountBytes = BitConverter.GetBytes(actionCount).Reverse().ToArray();
        var locations = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
        var packet = new FlowActionWrite().
                        WithOperationType(0x02). // 操作类型：2 写入动作包总数
                        WithMasterAddress<FlowActionWrite>(0xF2).
                        WithSlaveAddress<FlowActionWrite>(0x13).
                        WithActionSequence(actionsCountBytes). // 动作包总数
                        WithActionType(0x02). // 动作类型：2：理片
                        WithPickCount(0x00).  // 抓取次数：0次
                        WithSrcDstLocations(locations).
                        GenData();
        await _fixture.comPort.SendPacket(packet);
        await Task.Delay(200);

        byte[][] locationPairs = new byte[][]
        {
            new byte[] { 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x04, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x06, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x07, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x09, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x0A, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x0B, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x0D, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x0E, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x0F, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x10, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x11, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x12, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x13, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            new byte[] { 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
        };

        Enumerable.Range(0, actionCount).ToList().ForEach(async i =>
        {
            var actionPacket = new FlowActionWrite()
                .WithOperationType(0x01)
                .WithActionSequence(BitConverter.GetBytes(i + 1).Reverse().ToArray())
                .WithMasterAddress<FlowActionWrite>(0xF2)
                .WithSlaveAddress<FlowActionWrite>(0x13)
                .WithActionType(0x02)
                .WithPickCount(0x01)
                .WithSrcDstLocations(locationPairs[i])
                .GenData();

            await _fixture.comPort.SendPacket(actionPacket);
            await Task.Delay(200);
        });

        var actionsQuery = new FlowActionRead().
                                WithQuery(0x00);
        await _fixture.comPort.SendPacket(actionsQuery);
        await Task.Delay(200);

        var queryStepOne = new FlowActionRead().
                        WithQuery(0x01);
        await _fixture.comPort.SendPacket(queryStepOne);
        await Task.Delay(200);

        var boxTags = new byte[75];
        boxTags[0] = 0x01;
        var executeAction = new SystemStatusWrite().
                            WithOperationType(0x05).
                            WithMasterAddress<SystemStatusWrite>(0xF2).
                            WithSlaveAddress<SystemStatusWrite>(0x13).
                            WithBoxTags(boxTags);
        await _fixture.comPort.SendPacket(executeAction);
        await Task.Delay(1000);
    }

    public byte[][] GenerateLocationPairs(int steps, byte startPositionHigh, byte startPositionLow)
    {
        if (steps <= 0 || steps > 20)
        {
            throw new ArgumentException("步数必须在1到20之间。");
        }

        var locations = new List<byte[]>();
        byte currentPositionHigh = startPositionHigh;
        byte currentPositionLow = startPositionLow;

        for (int i = 0; i < steps - 1; i++)
        {
            byte nextPositionHigh = 0x00;
            byte nextPositionLow = (byte)((currentPositionLow + 1) % 21); // 假设位置是连续的，从1到20循环

            if (nextPositionLow == 0)
            {
                nextPositionLow = 0x01;
                nextPositionHigh = (byte)((currentPositionHigh + 1) % 21);
                if (nextPositionHigh == 0)
                {
                    nextPositionHigh = 0x01;
                }
            }

            locations.Add(new byte[] { currentPositionHigh, currentPositionLow, nextPositionHigh, nextPositionLow, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });

            currentPositionHigh = nextPositionHigh;
            currentPositionLow = nextPositionLow;
        }

        // 最后一步，将玻片移回起始位置
        locations.Add(new byte[] { currentPositionHigh, currentPositionLow, startPositionHigh, startPositionLow, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });

        return locations.ToArray();
    }
}

public class ComPortFixture : IAsyncLifetime
{
    public ComPort comPort { get; private set; }

    public async Task InitializeAsync()
    {
        var mockDevice = new Mock<Device>();
        var mockLogger = new Mock<ILogger>();
        var frameParser = new FrameParser(mockDevice.Object, mockLogger.Object);
        comPort = new ComPort(mockLogger.Object, frameParser);
        //await comPort.InitializeAsync("COM4", 115200);
    }

    public async Task DisposeAsync()
    {
        comPort.Close();
        await Task.CompletedTask;
    }
}